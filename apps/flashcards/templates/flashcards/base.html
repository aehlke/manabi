Sorry for the rudimentary user interface - it's just temporary. I'm focusing on functionality before I work on better usability. Promise things will look much nicer soon enough :)
<br>

<h2>Flashcards</h2>


<div dojoType="dijit.Declaration" widgetClass="DropDownMultiSelect" defaults="{ inputId: 'declaredDropDownMultiSelectInputC' }">
  <div dojoType="dijit.form.DropDownButton"  dojoAttachPoint="dropDownButton">
	  <span></span>
	  <div dojoType="dijit.layout.ContentPane">
  	  <select dojoType="dojox.form.CheckedMultiSelect" id="${inputId}" multiple="true" dojoAttachEvent="onChange: myClickHandler" dojoAttachPoint="multiSelect">
  	  </select>
	  </div>
	</div>
  <script type='dojo/connect' event='myClickHandler'>
    if (this.multiSelect.attr('value').length > 0) {
      var newLabel = this.multiSelect.attr('displayedValue').join(', ');
      this.dropDownButton.attr('label', newLabel);
      this.lastCardTemplatesInputValue = this.multiSelect.attr('value');
    } else {
      this.multiSelect.attr('value', this.lastCardTemplatesInputValue);
    }
  </script>
</div>




<button dojoType="dojox.form.BusyButton" jsId="addFlashcardsButton" busyLabel="Add Facts">
    Add Facts
	<script type="dojo/connect" event="onClick" args="evt">
	  //TODO get the URIs from the REST entry point
        function fetchStoreDeferred(dataStore, onItemCallback) {
            var dataStoreDef = new dojo.Deferred();
            dataStore.fetch({
                scope: dataStoreDef,
                onComplete: dataStoreDef.callback,
                onError: dataStoreDef.errback,
                onItem: onItemCallback
            });
            return dataStoreDef;
        }

        if (factTypeInputOnChangeHandle != null) {
            dojo.disconnect(factTypeInputOnChangeHandle);
        }
        
        var defArray = [];
        //populate DropDownSelects //todo:clean up
        dojo.forEach([{url:'/flashcards/rest/decks', jsId:'decksStore', nodeName:'deckInput'},
                      {url:'/flashcards/rest/fact_types', jsId:'factTypesStore', nodeName:'factTypeInput'}],
                      function(item) {
                          dojo.getObject(item['nodeName']).removeOption(dojo.getObject(item['nodeName']).getOptions());
                          var dataStore = new dojo.data.ItemFileReadStore({url: item['url'], jsId: item['jsId'], clearOnClose: true});
                          var dataStoreDef = fetchStoreDeferred(dataStore, function(defItem) {
                              dojo.getObject(item['nodeName']).addOption({value: dataStore.getValue(defItem, 'id'), label: dataStore.getValue(defItem, 'name')});
                          });
                          dataStoreDef.addCallback(function(items) {dojo.getObject(item['nodeName']).attr('value', items[0].id)});
                          defArray.push(dataStoreDef);
        });
        
        //first wait for decks/factTypes to finish loading
        var defList = new dojo.DeferredList(defArray);
        defList.addCallback(function() {
            //now prefetch fields based on the first factType option, then display the dialog
            var fieldsStoreDef = new dojo.Deferred();
            var cardTemplatesStoreDef = new dojo.Deferred();
            defList = new dojo.DeferredList([fieldsStoreDef, cardTemplatesStoreDef]);
            createFieldInputs(factTypeInput.attr('value'), function(items){cardTemplatesStoreDef.callback(items)}, function(items){fieldsStoreDef.callback(items);});
            
            factAddFormResults.attr('content', '');
            defList.addCallback(function() {
                //fields are prefetched and displayed - now we can show the dialog
                factTypeInputOnChangeHandle = dojo.connect(factTypeInput, 'onChange', null, createFieldInputs);
                addFlashcardsButton.cancel();
                
                factAddDialog.show();

                fact_add_ui.setKeyboardShortcuts();
            });
        });
	</script>
</button> Add new facts. Flashcards are generated from each fact.
<br>
<br>

<div dojoType="dijit.Dialog" jsId="factAddDialog" id="factAddDialog" title="Add Facts">
	<script type="dojo/connect" event="onClose" args="evt">
        fact_add_ui.unsetKeyboardShortcuts();
    </script>
    <div dojoType="dijit.form.Form" jsId="factAddForm" encType="multipart/form-data" action="" method="">
        
        <div>
        	<span>
        	    Deck: <input name="fact-deck" jsId="deckInput" dojoType="dojox.form.DropDownSelect"></input>
        	    Model: <input name="fact-fact_type" jsId="factTypeInput" dojoType="dojox.form.DropDownSelect"></input>
    	    </span>
        </div>
        <br>
        <div>
        	Cards: 
        	<div dojoType="DropDownMultiSelect" id="cardTemplatesInputButton" inputId="cardTemplatesInput" style="display:inline"></div>
        	<div id="cardTemplatesHiddenInput">
        	</div>
        </div>
        <br>
        <div id="factFields">
        </div>
        <br>
        <div>
            <span>
                <button dojoType="dijit.form.Button" type="submit">
            	    Add
            	</button> <button dojoType="dijit.form.Button">
            	    Close
            	    <script type="dojo/connect" event="onClick" args="evt">
                        factAddDialog.hide();
                    </script>
            	</button>
        	</span>
    	</div>
    	<div jsId="factAddFormResults" dojoType="dijit.layout.ContentPane"></div>
    </div>
</div>
<div jsId ="factAddDialogStandby" target="factAddDialog" dojoType="dojox.widget.Standby"></div>





<button dojoType="dojox.form.BusyButton" jsId="decksButton" busyLabel="Decks">
    Decks
    <script type="dojo/connect" event="onClick" args="evt">
        deckDialog.attr('href', 'flashcards/decks');
        deckDialog.show();
        decksButton.cancel();
    </script>
</button> Manage your decks, or download a shared deck.
<br>
<br>
<div dojoType="dijit.Dialog" jsId="deckDialog" id="deckDialog" title="Decks">
    
</div>


<button dojoType="dojox.form.BusyButton" jsId="factsButton" busyLabel="Facts">
Facts
<script type="dojo/connect" event="onClick" args="evt">
    //factsDialog.attr('href', 'facts');

//todo::deferreds
    //create fact_types store
    var factTypesStore = new dojo.data.ItemFileReadStore({url: 'flashcards/rest/fact_types', jsId: 'factTypesStore', clearOnClose: true});

    //create facts store
    
    factsDialogWidgets = [];
    factsDialogStores = [];
    
    //FIXME deselect (or reselect the correct row) when the grid is sorted on a column by the user, since right now it selects the first by default
    
    function beginFactsGridFactEditing(factTypeId, gridCpId, factRowIndex) {
        //destroy the previous form, if any
        dojo.query('#'+gridCpId+' > .factEditorForm').forEach(function(item){dijit.byId(item.id).destroyRecursive();});
        
        //enable the fact buttons on top of grid
        dijit.byId(dojo.query('#'+gridCpId+' > .deleteFactButton')[0].attributes.getNamedItem('widgetid').nodeValue).attr('disabled', false); //FIXME huge hack        
        
        var factsGridFactEditorCP = new dijit.layout.ContentPane({
                    style: 'height:200px;',
                    class: 'factEditorForm'
            }, document.createElement('div'));
        factsGridFactEditorCP.placeAt(gridCpId, 'last');
        factsGridFactEditorCP.startup();
        
        var fieldsStoreDef = new dojo.Deferred();
        var cardTemplatesStoreDef = new dojo.Deferred();
        defList = new dojo.DeferredList([fieldsStoreDef, cardTemplatesStoreDef]);
        
        //dijit.byId(factsGridFactEditorCP).attr('content', '');
        
        dijit.byId(gridCpId).attr('style','');
        
        var factsGridFactEditForm = new dijit.form.Form({
           encType: 'multipart/form-data' 
        }, document.createElement('div'));
        factsGridFactEditForm.placeAt(factsGridFactEditorCP.attr('id'), 'last');
        createFieldInputsForUpdate(factsGridFactEditForm.containerNode, factTypeId, this.getItem(factRowIndex), function(items){cardTemplatesStoreDef.callback(items)}, function(items){fieldsStoreDef.callback(items);});
        
        //factAddFormResults.attr('content', '');
        //save the fact store's item identity so that it can be used during form submit, even if the user selected something else (why not)
        defList.addCallback(dojo.hitch(null, function(factTypeId, factsGridFactEditForm, factId, gridCpId, factRowIndex) {
            dojo.place('<br><br>', factsGridFactEditForm.containerNode, 'last');
            var factsGridFactEditFormSubmitInput = new dijit.form.Button({
                label: 'Update',
                onClick: dojo.hitch(null, factFormSubmit,
                    function(data, tempCardCounter){
                        //update the grid item via the grid's store, to update the display (though the change has already gone to the server)
                        //get the item from the store
                        grid = dijit.byId(dojo.query('.dojoxGrid',dijit.byId(gridCpId).attr('id'))[0].id) //get the grid inside the contentpane //TODO this is so hacky
                        gridItem = grid.getItem(factRowIndex);
                        dojo.query('.field_content', factsGridFactEditForm.attr('id')).forEach(function(field_content_item) {
                            field_content_item = dijit.byId(field_content_item.id);
                            grid.store.setValue(gridItem, field_content_item.attr('gridStoreItemId'), field_content_item.attr('value'));
                        });
                        grid.store.save(); //FIXME handle error?
                        //hide editor
                        dojo.query('#'+gridCpId+' > .factEditorForm').forEach(function(item){dijit.byId(item.id).destroyRecursive();}); //TODO refactor into function
                        //deselect fact row on grid
                        grid.selection.deselect(factRowIndex);
                        
                        //disable the fact buttons on top of grid
                        dijit.byId(dojo.query('#'+gridCpId+' > .deleteFactButton')[0].attributes.getNamedItem('widgetid').nodeValue).attr('disabled', true); //FIXME huge hack
                    }, function(data, tempCardCounter) {
                      alert('error');
                    }, dijit.byId('cardUpdateTemplatesInput'+factTypeId), factsGridFactEditForm, factId, false)
            }).placeAt(factsGridFactEditForm.containerNode, 'last');
            var factsGridFactEditFormCancelInput = new dijit.form.Button({
                label: 'Cancel',
                onClick: dojo.hitch(null, function(factRowIndex, gridCpId) {
                    //FIXME this should be refactored to go with the above repeated code
                    //deselect fact row on grid
                    grid = dijit.byId(dojo.query('.dojoxGrid',dijit.byId(gridCpId).attr('id'))[0].id) //get the grid inside the contentpane //TODO this is so hacky
                    grid.selection.deselect(factRowIndex);
                    //disable the fact buttons on top of grid
                    dijit.byId(dojo.query('#'+gridCpId+' > .deleteFactButton')[0].attributes.getNamedItem('widgetid').nodeValue).attr('disabled', true); //FIXME huge hack
                    dojo.query('#'+gridCpId+' > .factEditorForm').forEach(function(item){dijit.byId(item.id).destroyRecursive();});
                }, factRowIndex, gridCpId)
            }).placeAt(factsGridFactEditForm.containerNode, 'last');
        }, factTypeId, factsGridFactEditForm, this.getItem(factRowIndex)['fact-id'][0], gridCpId, factRowIndex));
    }
    
    var factTypesStoreDef = new dojo.Deferred();
    factTypesStore.fetch({
        scope: this,
        onItem: function(item) {
            factsTabName = factTypesStore.getValue(item, 'name');
            
            var factStore = new dojo.data.ItemFileWriteStore({url:'/flashcards/rest/facts?fact_type='+factTypesStore.getValue(item, 'id'), clearOnClose:true});//'/flashcards/rest/fact_types/'+factTypesStore.getValue(item, 'id')+'/facts'
            factsDialogStores.push(factStore);
            var factTypeId = factTypesStore.getValue(item, 'id');
            var fieldTypesStore = new dojo.data.ItemFileReadStore({url:'/flashcards/rest/fact_types/'+factTypeId+'/fields', clearOnClose:true})
            factsDialogStores.push(fieldTypesStore);
            var newDef = new dojo.Deferred;
            newDef.addCallback(function(args) {
                var dataStruc = args.dataStructure;
                var realDataStruc = [dataStruc];
                var dataStore = args.dataStore;
                var factsGridCP = new dijit.layout.ContentPane({
                    title: args.tabName,
                    style:'height:160px;width:500px;align:left;'
                }, document.createElement('div'));
                factsDialogWidgets.push(factsGridCP);
                factTypesTabContainer.addChild(factsGridCP);
                var factsGrid = new dojox.grid.DataGrid({
                    query: {},
                    queryOptions: {deep:true},
                    store: factStore,
                    clientSort: true,
                    selectionMode: 'single', //TODO allow multiple (or extended)
                    rowSelector: false,
                    structure: realDataStruc,
                    title: args.tabName,
                    //style: 'height:250px;width:500px;',
                    onSelected: dojo.hitch(factsGrid, beginFactsGridFactEditing, args.tabFactTypeId, factsGridCP.attr('id'))
                }, document.createElement('div'));
                //factsDialogWidgets.push(factsGrid);
                factsGridCP.attr('content', factsGrid);
                factsGridCP.attr('style', 'height:400px;');
                
                //add 'delete fact' button on top of grid
                var deleteFactButton = new dijit.form.Button({
                    label: 'Delete',
                    class: 'deleteFactButton',
                    iconClass: 'dijitEditorIcon dijitEditorIconDelete',
                    disabled: true,
                    onClick: dojo.hitch(null, function(factsGrid) {
                        var deleteResponse = window.confirm('Really delete this fact?');
                        if (deleteResponse) {
                            gridItem = factsGrid.selection.getSelected()[0];
                            factId = gridItem['fact-id'][0]; //TODO allow multiple selections
                            var deferred = dojo.xhrPost({
                                url: '/flashcards/rest/facts/'+factId, //TODO get rid of hard-coded uri
                                handleAs: 'text',
                                content: { _method: 'DELETE' },
                                load: function(data) {
                                  //remove the deleted row from the grid store
                                  factsGrid.store.deleteItem(gridItem);
                                  factsGrid.store.save(); //FIXME handle error?
                                } //FIXME handle error - if fails, don't remove from store'
                            });
                        }
                    }, factsGrid)
                }).placeAt(factsGridCP.containerNode, 'first');//TODO factsDialogWidgets.push(
                
                factsDialog._position(); //TODO move this elsewhere - only needs to be called once
                factsGridFactEditorCP.placeAt(factsGridCP.attr('id'), 'last'); //FIXME does this even get placed?
                dojo.place('<hr>', factsGridCP.attr('id'), 'last');
                factsGrid.startup();
            });
            var fieldsStructure=new Array();
            fieldTypesStore.fetch({
                scope: this,
                onItem: function(fieldTypesItem) {
                    var tempn = fieldTypesStore.getValue(fieldTypesItem, 'id');
                    tnum = 'id'+tempn;
                    fieldsStructure.push({
                        field: tnum,
                        name: fieldTypesStore.getValue(fieldTypesItem, 'name'),
                        width: 'auto'
                    });
                },
                onComplete:dojo.hitch(newDef, 'callback', {dataStructure:fieldsStructure, dataStore:factStore, tabName:factsTabName, tabFactTypeId:factTypeId})//{dataStructure:fieldsStructure, cpJsId:cp.attr('jsId'), dataStore:factsStore}) 
            });
        }
    });
    factsButton.cancel();
    
    
    dojo.connect(factsDialog, 'onCancel', function() {
        dojo.forEach(factsDialogWidgets, function(item) {
            factTypesTabContainer.removeChild(item);
           item.destroyRecursive();
        })
        //factTypesTabContainer.destroyDescendants();
        factsDialogWidgets = [];
        dojo.forEach(factsDialogStores, function(item) {
           item.close();
        });
        factTypesStore.close();
    });
    
    factsDialog.show();

</script>
</button> View or edit existing flashcard facts.
<br>
<br>
<div dojoType="dijit.Dialog" jsId="factsDialog" id="factsDialog" title="Facts">
    <div dojoType="dijit.layout.TabContainer" jsId="factTypesTabContainer" doLayout="false">

    </div>
</div>

{% include 'flashcards/reviews.html' %}

